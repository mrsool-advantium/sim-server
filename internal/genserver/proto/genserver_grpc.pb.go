// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.3
// source: genserver.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SimulatedDriver_GoOnline_FullMethodName       = "/genserver.SimulatedDriver/GoOnline"
	SimulatedDriver_InitConnection_FullMethodName = "/genserver.SimulatedDriver/InitConnection"
	SimulatedDriver_SetLocation_FullMethodName    = "/genserver.SimulatedDriver/SetLocation"
	SimulatedDriver_IsAlive_FullMethodName        = "/genserver.SimulatedDriver/IsAlive"
)

// SimulatedDriverClient is the client API for SimulatedDriver service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SimulatedDriverClient interface {
	GoOnline(ctx context.Context, in *GoOnlineRequest, opts ...grpc.CallOption) (*GoOnlineResponse, error)
	InitConnection(ctx context.Context, in *InitConnectionRequest, opts ...grpc.CallOption) (*InitConnectionResponse, error)
	SetLocation(ctx context.Context, in *SetLocationRequest, opts ...grpc.CallOption) (*SetLocationResponse, error)
	IsAlive(ctx context.Context, in *IsAliveRequest, opts ...grpc.CallOption) (*IsAliveResponse, error)
}

type simulatedDriverClient struct {
	cc grpc.ClientConnInterface
}

func NewSimulatedDriverClient(cc grpc.ClientConnInterface) SimulatedDriverClient {
	return &simulatedDriverClient{cc}
}

func (c *simulatedDriverClient) GoOnline(ctx context.Context, in *GoOnlineRequest, opts ...grpc.CallOption) (*GoOnlineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GoOnlineResponse)
	err := c.cc.Invoke(ctx, SimulatedDriver_GoOnline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulatedDriverClient) InitConnection(ctx context.Context, in *InitConnectionRequest, opts ...grpc.CallOption) (*InitConnectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitConnectionResponse)
	err := c.cc.Invoke(ctx, SimulatedDriver_InitConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulatedDriverClient) SetLocation(ctx context.Context, in *SetLocationRequest, opts ...grpc.CallOption) (*SetLocationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetLocationResponse)
	err := c.cc.Invoke(ctx, SimulatedDriver_SetLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulatedDriverClient) IsAlive(ctx context.Context, in *IsAliveRequest, opts ...grpc.CallOption) (*IsAliveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsAliveResponse)
	err := c.cc.Invoke(ctx, SimulatedDriver_IsAlive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SimulatedDriverServer is the server API for SimulatedDriver service.
// All implementations must embed UnimplementedSimulatedDriverServer
// for forward compatibility.
type SimulatedDriverServer interface {
	GoOnline(context.Context, *GoOnlineRequest) (*GoOnlineResponse, error)
	InitConnection(context.Context, *InitConnectionRequest) (*InitConnectionResponse, error)
	SetLocation(context.Context, *SetLocationRequest) (*SetLocationResponse, error)
	IsAlive(context.Context, *IsAliveRequest) (*IsAliveResponse, error)
	mustEmbedUnimplementedSimulatedDriverServer()
}

// UnimplementedSimulatedDriverServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSimulatedDriverServer struct{}

func (UnimplementedSimulatedDriverServer) GoOnline(context.Context, *GoOnlineRequest) (*GoOnlineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GoOnline not implemented")
}
func (UnimplementedSimulatedDriverServer) InitConnection(context.Context, *InitConnectionRequest) (*InitConnectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitConnection not implemented")
}
func (UnimplementedSimulatedDriverServer) SetLocation(context.Context, *SetLocationRequest) (*SetLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLocation not implemented")
}
func (UnimplementedSimulatedDriverServer) IsAlive(context.Context, *IsAliveRequest) (*IsAliveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAlive not implemented")
}
func (UnimplementedSimulatedDriverServer) mustEmbedUnimplementedSimulatedDriverServer() {}
func (UnimplementedSimulatedDriverServer) testEmbeddedByValue()                         {}

// UnsafeSimulatedDriverServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SimulatedDriverServer will
// result in compilation errors.
type UnsafeSimulatedDriverServer interface {
	mustEmbedUnimplementedSimulatedDriverServer()
}

func RegisterSimulatedDriverServer(s grpc.ServiceRegistrar, srv SimulatedDriverServer) {
	// If the following call pancis, it indicates UnimplementedSimulatedDriverServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SimulatedDriver_ServiceDesc, srv)
}

func _SimulatedDriver_GoOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GoOnlineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulatedDriverServer).GoOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulatedDriver_GoOnline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulatedDriverServer).GoOnline(ctx, req.(*GoOnlineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulatedDriver_InitConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulatedDriverServer).InitConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulatedDriver_InitConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulatedDriverServer).InitConnection(ctx, req.(*InitConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulatedDriver_SetLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulatedDriverServer).SetLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulatedDriver_SetLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulatedDriverServer).SetLocation(ctx, req.(*SetLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulatedDriver_IsAlive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsAliveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulatedDriverServer).IsAlive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulatedDriver_IsAlive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulatedDriverServer).IsAlive(ctx, req.(*IsAliveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SimulatedDriver_ServiceDesc is the grpc.ServiceDesc for SimulatedDriver service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SimulatedDriver_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "genserver.SimulatedDriver",
	HandlerType: (*SimulatedDriverServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GoOnline",
			Handler:    _SimulatedDriver_GoOnline_Handler,
		},
		{
			MethodName: "InitConnection",
			Handler:    _SimulatedDriver_InitConnection_Handler,
		},
		{
			MethodName: "SetLocation",
			Handler:    _SimulatedDriver_SetLocation_Handler,
		},
		{
			MethodName: "IsAlive",
			Handler:    _SimulatedDriver_IsAlive_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "genserver.proto",
}

const (
	SimulatedCustomer_InitConnection_FullMethodName = "/genserver.SimulatedCustomer/InitConnection"
	SimulatedCustomer_SetLocation_FullMethodName    = "/genserver.SimulatedCustomer/SetLocation"
	SimulatedCustomer_IsAlive_FullMethodName        = "/genserver.SimulatedCustomer/IsAlive"
	SimulatedCustomer_TripEstimate_FullMethodName   = "/genserver.SimulatedCustomer/TripEstimate"
	SimulatedCustomer_ConfirmTrip_FullMethodName    = "/genserver.SimulatedCustomer/ConfirmTrip"
)

// SimulatedCustomerClient is the client API for SimulatedCustomer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SimulatedCustomerClient interface {
	InitConnection(ctx context.Context, in *InitConnectionRequest, opts ...grpc.CallOption) (*InitConnectionResponse, error)
	SetLocation(ctx context.Context, in *SetLocationRequest, opts ...grpc.CallOption) (*SetLocationResponse, error)
	IsAlive(ctx context.Context, in *IsAliveRequest, opts ...grpc.CallOption) (*IsAliveResponse, error)
	TripEstimate(ctx context.Context, in *TripEstimateRequest, opts ...grpc.CallOption) (*TripEstimateResponse, error)
	ConfirmTrip(ctx context.Context, in *ConfirmTripRequest, opts ...grpc.CallOption) (*ConfirmTripResponse, error)
}

type simulatedCustomerClient struct {
	cc grpc.ClientConnInterface
}

func NewSimulatedCustomerClient(cc grpc.ClientConnInterface) SimulatedCustomerClient {
	return &simulatedCustomerClient{cc}
}

func (c *simulatedCustomerClient) InitConnection(ctx context.Context, in *InitConnectionRequest, opts ...grpc.CallOption) (*InitConnectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitConnectionResponse)
	err := c.cc.Invoke(ctx, SimulatedCustomer_InitConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulatedCustomerClient) SetLocation(ctx context.Context, in *SetLocationRequest, opts ...grpc.CallOption) (*SetLocationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetLocationResponse)
	err := c.cc.Invoke(ctx, SimulatedCustomer_SetLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulatedCustomerClient) IsAlive(ctx context.Context, in *IsAliveRequest, opts ...grpc.CallOption) (*IsAliveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsAliveResponse)
	err := c.cc.Invoke(ctx, SimulatedCustomer_IsAlive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulatedCustomerClient) TripEstimate(ctx context.Context, in *TripEstimateRequest, opts ...grpc.CallOption) (*TripEstimateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TripEstimateResponse)
	err := c.cc.Invoke(ctx, SimulatedCustomer_TripEstimate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulatedCustomerClient) ConfirmTrip(ctx context.Context, in *ConfirmTripRequest, opts ...grpc.CallOption) (*ConfirmTripResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfirmTripResponse)
	err := c.cc.Invoke(ctx, SimulatedCustomer_ConfirmTrip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SimulatedCustomerServer is the server API for SimulatedCustomer service.
// All implementations must embed UnimplementedSimulatedCustomerServer
// for forward compatibility.
type SimulatedCustomerServer interface {
	InitConnection(context.Context, *InitConnectionRequest) (*InitConnectionResponse, error)
	SetLocation(context.Context, *SetLocationRequest) (*SetLocationResponse, error)
	IsAlive(context.Context, *IsAliveRequest) (*IsAliveResponse, error)
	TripEstimate(context.Context, *TripEstimateRequest) (*TripEstimateResponse, error)
	ConfirmTrip(context.Context, *ConfirmTripRequest) (*ConfirmTripResponse, error)
	mustEmbedUnimplementedSimulatedCustomerServer()
}

// UnimplementedSimulatedCustomerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSimulatedCustomerServer struct{}

func (UnimplementedSimulatedCustomerServer) InitConnection(context.Context, *InitConnectionRequest) (*InitConnectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitConnection not implemented")
}
func (UnimplementedSimulatedCustomerServer) SetLocation(context.Context, *SetLocationRequest) (*SetLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLocation not implemented")
}
func (UnimplementedSimulatedCustomerServer) IsAlive(context.Context, *IsAliveRequest) (*IsAliveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAlive not implemented")
}
func (UnimplementedSimulatedCustomerServer) TripEstimate(context.Context, *TripEstimateRequest) (*TripEstimateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TripEstimate not implemented")
}
func (UnimplementedSimulatedCustomerServer) ConfirmTrip(context.Context, *ConfirmTripRequest) (*ConfirmTripResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmTrip not implemented")
}
func (UnimplementedSimulatedCustomerServer) mustEmbedUnimplementedSimulatedCustomerServer() {}
func (UnimplementedSimulatedCustomerServer) testEmbeddedByValue()                           {}

// UnsafeSimulatedCustomerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SimulatedCustomerServer will
// result in compilation errors.
type UnsafeSimulatedCustomerServer interface {
	mustEmbedUnimplementedSimulatedCustomerServer()
}

func RegisterSimulatedCustomerServer(s grpc.ServiceRegistrar, srv SimulatedCustomerServer) {
	// If the following call pancis, it indicates UnimplementedSimulatedCustomerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SimulatedCustomer_ServiceDesc, srv)
}

func _SimulatedCustomer_InitConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulatedCustomerServer).InitConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulatedCustomer_InitConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulatedCustomerServer).InitConnection(ctx, req.(*InitConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulatedCustomer_SetLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulatedCustomerServer).SetLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulatedCustomer_SetLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulatedCustomerServer).SetLocation(ctx, req.(*SetLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulatedCustomer_IsAlive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsAliveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulatedCustomerServer).IsAlive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulatedCustomer_IsAlive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulatedCustomerServer).IsAlive(ctx, req.(*IsAliveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulatedCustomer_TripEstimate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TripEstimateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulatedCustomerServer).TripEstimate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulatedCustomer_TripEstimate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulatedCustomerServer).TripEstimate(ctx, req.(*TripEstimateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulatedCustomer_ConfirmTrip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmTripRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulatedCustomerServer).ConfirmTrip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulatedCustomer_ConfirmTrip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulatedCustomerServer).ConfirmTrip(ctx, req.(*ConfirmTripRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SimulatedCustomer_ServiceDesc is the grpc.ServiceDesc for SimulatedCustomer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SimulatedCustomer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "genserver.SimulatedCustomer",
	HandlerType: (*SimulatedCustomerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitConnection",
			Handler:    _SimulatedCustomer_InitConnection_Handler,
		},
		{
			MethodName: "SetLocation",
			Handler:    _SimulatedCustomer_SetLocation_Handler,
		},
		{
			MethodName: "IsAlive",
			Handler:    _SimulatedCustomer_IsAlive_Handler,
		},
		{
			MethodName: "TripEstimate",
			Handler:    _SimulatedCustomer_TripEstimate_Handler,
		},
		{
			MethodName: "ConfirmTrip",
			Handler:    _SimulatedCustomer_ConfirmTrip_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "genserver.proto",
}

const (
	GenServer_HandleCall_FullMethodName = "/genserver.GenServer/HandleCall"
	GenServer_HandleCast_FullMethodName = "/genserver.GenServer/HandleCast"
)

// GenServerClient is the client API for GenServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GenServerClient interface {
	HandleCall(ctx context.Context, in *HandleCallRequest, opts ...grpc.CallOption) (*HandleCallResponse, error)
	HandleCast(ctx context.Context, in *HandleCastRequest, opts ...grpc.CallOption) (*HandleCastResponse, error)
}

type genServerClient struct {
	cc grpc.ClientConnInterface
}

func NewGenServerClient(cc grpc.ClientConnInterface) GenServerClient {
	return &genServerClient{cc}
}

func (c *genServerClient) HandleCall(ctx context.Context, in *HandleCallRequest, opts ...grpc.CallOption) (*HandleCallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HandleCallResponse)
	err := c.cc.Invoke(ctx, GenServer_HandleCall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *genServerClient) HandleCast(ctx context.Context, in *HandleCastRequest, opts ...grpc.CallOption) (*HandleCastResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HandleCastResponse)
	err := c.cc.Invoke(ctx, GenServer_HandleCast_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GenServerServer is the server API for GenServer service.
// All implementations must embed UnimplementedGenServerServer
// for forward compatibility.
type GenServerServer interface {
	HandleCall(context.Context, *HandleCallRequest) (*HandleCallResponse, error)
	HandleCast(context.Context, *HandleCastRequest) (*HandleCastResponse, error)
	mustEmbedUnimplementedGenServerServer()
}

// UnimplementedGenServerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGenServerServer struct{}

func (UnimplementedGenServerServer) HandleCall(context.Context, *HandleCallRequest) (*HandleCallResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleCall not implemented")
}
func (UnimplementedGenServerServer) HandleCast(context.Context, *HandleCastRequest) (*HandleCastResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleCast not implemented")
}
func (UnimplementedGenServerServer) mustEmbedUnimplementedGenServerServer() {}
func (UnimplementedGenServerServer) testEmbeddedByValue()                   {}

// UnsafeGenServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GenServerServer will
// result in compilation errors.
type UnsafeGenServerServer interface {
	mustEmbedUnimplementedGenServerServer()
}

func RegisterGenServerServer(s grpc.ServiceRegistrar, srv GenServerServer) {
	// If the following call pancis, it indicates UnimplementedGenServerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GenServer_ServiceDesc, srv)
}

func _GenServer_HandleCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GenServerServer).HandleCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GenServer_HandleCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GenServerServer).HandleCall(ctx, req.(*HandleCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GenServer_HandleCast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleCastRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GenServerServer).HandleCast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GenServer_HandleCast_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GenServerServer).HandleCast(ctx, req.(*HandleCastRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GenServer_ServiceDesc is the grpc.ServiceDesc for GenServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GenServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "genserver.GenServer",
	HandlerType: (*GenServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandleCall",
			Handler:    _GenServer_HandleCall_Handler,
		},
		{
			MethodName: "HandleCast",
			Handler:    _GenServer_HandleCast_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "genserver.proto",
}
